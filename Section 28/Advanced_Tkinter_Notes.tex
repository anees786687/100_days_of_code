\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{graphicx}

\geometry{margin=1in}

% Define colors for code highlighting
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Code style
\lstdefinestyle{pythonstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=Python
}

\lstset{style=pythonstyle}

\title{\textbf{Advanced Tkinter Concepts: Pomodoro Timer Project}}
\author{Section 28 - GUI Programming with Tkinter}
\date{September 2025}

\begin{document}

\maketitle

\section{Canvas Widget - Advanced Graphics}

\subsection{Canvas Fundamentals}
The \texttt{Canvas} widget allows layering of graphical elements, essential for complex UIs:

\begin{lstlisting}
# Creating a canvas
canvas = Canvas(width=200, height=224, bg=YELLOW, highlightthickness=0)

# Adding images to canvas
tomato_img = PhotoImage(file='tomato.png')
canvas.create_image(100, 112, image=tomato_img)

# Adding text on top of images
timer_text = canvas.create_text(103, 130, text="25:00", 
                               fill='white', font=("Courier", 30, "bold"))
\end{lstlisting}

\subsection{Canvas Coordinate System}
\begin{itemize}
    \item Origin (0,0) at top-left corner
    \item X increases rightward, Y increases downward
    \item \texttt{create\_image(x, y, image=img)} - centers image at (x,y)
    \item \texttt{create\_text(x, y, text="...", options)} - positions text
\end{itemize}

\subsection{Dynamic Canvas Updates}
\textbf{Key Learning:} Canvas items can be modified after creation:

\begin{lstlisting}
# Store canvas item reference
timer_text = canvas.create_text(100, 130, text="25:00")

# Update the text dynamically
canvas.itemconfig(timer_text, text="24:59")
\end{lstlisting}

\section{Grid Layout System - Advanced Techniques}

\subsection{Grid Weights for Responsive Design}
\textbf{New Concept:} \texttt{columnconfigure()} and \texttt{rowconfigure()} for responsive layouts:

\begin{lstlisting}
# Make columns expandable
window.columnconfigure(0, weight=1)
window.columnconfigure(1, weight=1) 
window.columnconfigure(2, weight=1)

# Widgets now resize proportionally
start_button.grid(row=2, column=0, sticky="ew")
\end{lstlisting}

\subsection{Sticky Options}
\begin{itemize}
    \item \texttt{sticky="ew"} - Expand East-West (horizontally)
    \item \texttt{sticky="ns"} - Expand North-South (vertically)  
    \item \texttt{sticky="nsew"} - Fill entire cell
\end{itemize}

\section{Timer Programming with \texttt{after()}}

\subsection{Non-blocking Timer Implementation}
\textbf{Critical Concept:} Using \texttt{window.after()} instead of \texttt{time.sleep()}:

\begin{lstlisting}
def countdown(self, count):
    if count > 0:
        # Schedule next update in 1000ms (1 second)
        self.timer_job = self.window.after(1000, self.countdown, count - 1)
    else:
        self.timer_finished()
\end{lstlisting}

\subsection{Timer Management}
\textbf{Important:} Always store and cancel timer jobs properly:

\begin{lstlisting}
# Store timer reference
self.timer_job = self.window.after(1000, self.countdown, count - 1)

# Cancel timer when needed (reset functionality)
if self.timer_job:
    self.window.after_cancel(self.timer_job)
\end{lstlisting}

\section{Error Handling in GUI Applications}

\subsection{Graceful Image Loading}
\textbf{Professional Practice:} Always handle missing resources:

\begin{lstlisting}
try:
    image_path = os.path.join(os.path.dirname(__file__), 'tomato.png')
    self.tomato_img = PhotoImage(file=image_path)
    self.canvas.create_image(100, 112, image=self.tomato_img)
except Exception as e:
    print(f"Could not load image: {e}")
    # Fallback: Create simple shapes
    self.canvas.create_oval(50, 50, 150, 150, fill=RED, outline=GREEN)
\end{lstlisting}

\section{State Management in GUI Applications}

\subsection{Class-Based State Management}
\textbf{Best Practice:} Encapsulate state within class instances:

\begin{lstlisting}
class PomodoroTimer:
    def __init__(self):
        # Centralized state management
        self.reset_pressed = False
        self.check_count = 0
        self.state = 'work'  # 'work', 'short_break', 'long_break'
        self.timer_job = None
\end{lstlisting}

\subsection{State Machine Implementation}
\textbf{Advanced Pattern:} Implementing state transitions:

\begin{lstlisting}
def timer_finished(self):
    if self.state == 'work':
        self.check_count += 1
        if self.check_count % 4 == 0:
            self.state = 'long_break'
        else:
            self.state = 'short_break'
    else:
        self.state = 'work'
    
    self.start_timer()  # Auto-transition to next state
\end{lstlisting}

\section{Dynamic UI Updates}

\subsection{Conditional UI Styling}
\textbf{User Experience:} Update UI based on application state:

\begin{lstlisting}
def start_timer(self):
    if self.state == 'work':
        self.timer_label.config(text="Work", fg=GREEN)
    elif self.state == 'short_break':
        self.timer_label.config(text="Short Break", fg=PINK)
    elif self.state == 'long_break':
        self.timer_label.config(text="Long Break", fg=RED)
\end{lstlisting}

\subsection{Progress Indicators}
\textbf{Visual Feedback:} Dynamic content generation:

\begin{lstlisting}
def update_check_marks(self):
    # Generate checkmarks based on completed sessions
    marks = 'v' * (self.check_count % 4)  # Using 'v' for checkmarks
    self.check_label.config(text=marks)
\end{lstlisting}

\section{File Path Management}

\subsection{Cross-Platform Path Handling}
\textbf{Portability:} Use \texttt{os.path.join()} for file paths:

\begin{lstlisting}
import os

# Wrong: Hard-coded path separators
# image_path = './tomato.png'  # May fail on different OS

# Correct: OS-independent path construction
image_path = os.path.join(os.path.dirname(__file__), 'tomato.png')
\end{lstlisting}

\section{Advanced Widget Configuration}

\subsection{Padding and Spacing}
\textbf{Layout Control:} Multiple padding techniques:

\begin{lstlisting}
# Window-level padding
window.config(padx=100, pady=50)

# Widget-level padding during grid placement
button.grid(row=2, column=0, pady=20, padx=(0, 10))

# Internal widget padding
button.config(font=("Courier", 12), highlightthickness=0)
\end{lstlisting}

\subsection{Font Tuples}
\textbf{Typography:} Proper font specification:

\begin{lstlisting}
# Font tuple: (family, size, style)
font_normal = ("Courier", 32, 'normal')
font_bold = ("Courier", 30, "bold")

label = Label(text="Timer", font=font_normal)
\end{lstlisting}

\section{Object-Oriented GUI Design}

\subsection{Separation of Concerns}
\textbf{Architecture:} Separate UI setup from business logic:

\begin{lstlisting}
class PomodoroTimer:
    def __init__(self):
        self.setup_state()
        self.setup_ui()
    
    def setup_ui(self):
        """Handle all UI creation"""
        self.create_window()
        self.create_canvas()
        self.create_controls()
    
    def start_timer(self):
        """Handle business logic"""
        # Timer logic here
\end{lstlisting}

\section{Key Takeaways}

\begin{enumerate}[label=\textbf{\arabic*.}]
    \item \textbf{Canvas Layering:} Images and text can be layered on canvas with precise positioning
    \item \textbf{Non-blocking Timers:} Use \texttt{window.after()} for responsive UI updates
    \item \textbf{State Management:} Centralize application state in class attributes
    \item \textbf{Error Handling:} Always provide fallbacks for external resources
    \item \textbf{Responsive Design:} Use grid weights and sticky options for scalable layouts
    \item \textbf{Dynamic Updates:} Change widget properties based on application state
    \item \textbf{Professional Structure:} Organize code into logical methods and classes
\end{enumerate}

\section{Common Patterns Learned}

\subsection{Timer Pattern}
\begin{lstlisting}
# Recursive timer with proper cleanup
def countdown(self, seconds):
    if self.should_continue and seconds > 0:
        self.update_display(seconds)
        self.timer_job = self.window.after(1000, self.countdown, seconds-1)
    else:
        self.timer_completed()
\end{lstlisting}

\subsection{State Machine Pattern}
\begin{lstlisting}
# State transitions with automatic progression
def transition_state(self):
    if self.current_state == 'work':
        self.next_state = 'break' if self.session_count < 4 else 'long_break'
    elif self.current_state in ['break', 'long_break']:
        self.next_state = 'work'
    
    self.current_state = self.next_state
    self.update_ui_for_state()
\end{lstlisting}

\vspace{1cm}
\hrule
\vspace{0.5cm}
\textit{These concepts represent a significant advancement from basic Tkinter widgets to professional GUI application development, incorporating proper software engineering practices and user experience design.}

\end{document}

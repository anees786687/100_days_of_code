\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{tcolorbox}
\usepackage{enumitem}

% Code styling
\lstdefinestyle{pythonstyle}{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    numberstyle=\tiny\color{gray},
    breaklines=true,
    showstringspaces=false,
    frame=single,
    backgroundcolor=\color{gray!10}
}

\lstset{style=pythonstyle}

% Header and footer
\pagestyle{fancy}
\fancyhf{}
\rhead{Sections 27-28: Complete Tkinter GUI Programming}
\lhead{100 Days of Code}
\cfoot{\thepage}

% Title page setup
\title{\textbf{Sections 27-28: Complete Tkinter GUI Programming}\\
\large{From Basics to Professional Applications}}
\author{100 Days of Code - Python Bootcamp}
\date{\today}

\begin{document}

\maketitle
\newpage

\tableofcontents
\newpage

\section{Introduction}

This comprehensive guide covers two interconnected sections that together provide complete mastery of GUI programming in Python:

\textbf{Section 27 - Foundations:}
\begin{itemize}
    \item \textbf{Tkinter}: Python's standard GUI toolkit
    \item \textbf{*args}: Variable-length positional arguments
    \item \textbf{**kwargs}: Variable-length keyword arguments
    \item \textbf{Basic widgets and layouts}
\end{itemize}

\textbf{Section 28 - Advanced Techniques:}
\begin{itemize}
    \item \textbf{Canvas graphics and animations}
    \item \textbf{Non-blocking timers and state management}
    \item \textbf{Professional code organization}
    \item \textbf{Error handling and robustness}
\end{itemize}

\section{Function Arguments: *args and **kwargs}

\subsection{*args - Variable Positional Arguments}

The \texttt{*args} parameter allows functions to accept any number of positional arguments, which are collected into a tuple.

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black,title=*args Example]
\begin{lstlisting}
def add(*args):
    """Add unlimited number of arguments"""
    sum = 0
    for n in args:
        sum += n
    return sum

# Usage examples
print(add(1, 2, 3, 4, 5))        # Output: 15
print(add(10, 20))               # Output: 30
print(add(1))                    # Output: 1
\end{lstlisting}
\end{tcolorbox}

\subsection{**kwargs - Variable Keyword Arguments}

The \texttt{**kwargs} parameter allows functions to accept any number of keyword arguments, which are collected into a dictionary.

\begin{tcolorbox}[colback=green!5!white,colframe=green!75!black,title=**kwargs Example]
\begin{lstlisting}
def calculate(n, **kwargs):
    """Perform calculations based on keyword arguments"""
    n += kwargs.get('add', 0)      # Default to 0 if 'add' not provided
    n *= kwargs.get('multiply', 1)  # Default to 1 if 'multiply' not provided
    return n

# Usage examples
result = calculate(5, add=3, multiply=5)  # (5 + 3) * 5 = 40
print(result)
\end{lstlisting}
\end{tcolorbox}

\subsection{Class Constructors with **kwargs}

Object-oriented programming benefits greatly from **kwargs in constructors:

\begin{tcolorbox}[colback=orange!5!white,colframe=orange!75!black,title=Class with **kwargs]
\begin{lstlisting}
class Car:
    def __init__(self, **kwargs):
        # Safe way to get values with defaults
        self.make = kwargs.get('make', 'Unknown')
        self.model = kwargs.get('model', 'Unknown')
        self.year = kwargs.get('year', 2024)
    
    def details_print(self):
        print(f"{self.year} {self.make} {self.model}")

# Usage examples
car1 = Car(make='Ford', model='Fiesta', year=2023)
car2 = Car(make='Toyota')  # Missing model and year use defaults
car1.details_print()  # Output: 2023 Ford Fiesta
car2.details_print()  # Output: 2024 Toyota Unknown
\end{lstlisting}
\end{tcolorbox}

\section{Basic Tkinter Programming (Section 27)}

\subsection{Essential Widgets and Layout}

\subsubsection{Basic Window and Widget Creation}

\begin{tcolorbox}[colback=purple!5!white,colframe=purple!75!black,title=Basic GUI Setup]
\begin{lstlisting}
import tkinter as tk

# Create main window
window = tk.Tk()
window.title('My First GUI Application')
window.minsize(width=500, height=300)
window.config(padx=20, pady=20)

# Create widgets
label = tk.Label(text='Welcome to Tkinter!', font=('Arial', 12, 'bold'))
button = tk.Button(text='Click Me', command=lambda: print("Clicked!"))
entry = tk.Entry(width=30)

# Layout with grid
label.grid(row=0, column=1)
entry.grid(row=1, column=1, pady=5)
button.grid(row=2, column=1, pady=10)

window.mainloop()
\end{lstlisting}
\end{tcolorbox}

\subsubsection{Layout Managers}

\textbf{Grid Layout (Recommended):}
\begin{lstlisting}
widget.grid(row=0, column=1, padx=5, pady=5, sticky='ew')
\end{lstlisting}

\textbf{Pack Layout:}
\begin{lstlisting}
widget.pack(side='top', fill='x', expand=True)
\end{lstlisting}

\section{Advanced Tkinter Concepts (Section 28)}

\subsection{Canvas Widget - Advanced Graphics}

\subsubsection{Canvas with Images and Text Overlay}
The \texttt{Canvas} widget enables sophisticated graphics and layering:

\begin{tcolorbox}[colback=blue!5!white,colframe=blue!75!black,title=Canvas with Images and Text]
\begin{lstlisting}
# Creating a canvas with precise dimensions
canvas = Canvas(width=200, height=224, bg=YELLOW, highlightthickness=0)

# Loading and displaying images
tomato_img = PhotoImage(file='tomato.png')
canvas.create_image(100, 112, image=tomato_img)

# Overlaying text on images
timer_text = canvas.create_text(103, 130, text="25:00", 
                               fill='white', font=("Courier", 30, "bold"))
canvas.grid(row=1, column=1)
\end{lstlisting}
\end{tcolorbox}

\subsubsection{Dynamic Canvas Updates}
\textbf{Key Concept:} Canvas items can be modified after creation:

\begin{lstlisting}
# Store canvas item reference for later updates
timer_text = canvas.create_text(100, 130, text="25:00")

# Dynamically update content
canvas.itemconfig(timer_text, text="24:59")
canvas.itemconfig(timer_text, fill="red")  # Change color
\end{lstlisting}

\subsubsection{Error Handling with Graphics}
\textbf{Professional Practice:} Always provide fallbacks for missing resources:

\begin{lstlisting}
try:
    image_path = os.path.join(os.path.dirname(__file__), 'tomato.png')
    tomato_img = PhotoImage(file=image_path)
    canvas.create_image(100, 112, image=tomato_img)
except Exception as e:
    print(f"Could not load image: {e}")
    # Fallback: Create geometric shapes
    canvas.create_oval(50, 50, 150, 150, fill="red", outline="green", width=3)
\end{lstlisting}

\subsection{Advanced Grid Layout Techniques}

\subsubsection{Responsive Design with Grid Weights}
\textbf{Professional Layout:} Make interfaces that adapt to window resizing:

\begin{lstlisting}
# Configure column weights for proportional resizing
window.columnconfigure(0, weight=1)
window.columnconfigure(1, weight=1) 
window.columnconfigure(2, weight=1)

# Widgets expand to fill available space
start_button.grid(row=2, column=0, sticky="ew", padx=(0, 10))
reset_button.grid(row=2, column=2, sticky="ew", padx=(10, 0))
\end{lstlisting}

\subsection{Non-blocking Timer Programming}

\subsubsection{The \texttt{window.after()} Method}
\textbf{Critical Concept:} Use \texttt{after()} instead of \texttt{time.sleep()} for GUI responsiveness:

\begin{tcolorbox}[colback=green!5!white,colframe=green!75!black,title=Professional Timer Implementation]
\begin{lstlisting}
class PomodoroTimer:
    def countdown(self, count):
        """Non-blocking countdown implementation"""
        if self.reset_pressed:
            return
            
        minutes = count // 60
        seconds = count % 60
        time_text = f'{minutes}:{seconds:02d}'
        
        # Update display
        self.canvas.itemconfig(self.timer_text, text=time_text)
        
        if count > 0:
            # Schedule next update in 1000ms
            self.timer_job = self.window.after(1000, self.countdown, count - 1)
        else:
            self.timer_finished()
\end{lstlisting}
\end{tcolorbox}

\subsubsection{Timer Management and Cleanup}
\textbf{Important:} Always manage timer jobs properly:

\begin{lstlisting}
def reset_timer(self):
    """Properly cancel and reset timer"""
    if self.timer_job:
        self.window.after_cancel(self.timer_job)  # Cancel scheduled callback
    
    # Reset state and UI
    self.timer_job = None
    self.canvas.itemconfig(self.timer_text, text="25:00")
\end{lstlisting}

\subsection{State Management in GUI Applications}

\subsubsection{Class-Based State Organization}
\textbf{Best Practice:} Encapsulate application state within classes:

\begin{lstlisting}
class PomodoroTimer:
    def __init__(self):
        # Centralized state management
        self.reset_pressed = False
        self.check_count = 0
        self.state = 'work'  # Current timer state
        self.timer_job = None  # Active timer reference
        
        self.setup_ui()
\end{lstlisting}

\subsubsection{State Machine Implementation}
\textbf{Advanced Pattern:} Implement clean state transitions:

\begin{lstlisting}
def timer_finished(self):
    """Handle state transitions after timer completion"""
    if self.state == 'work':
        self.check_count += 1
        self.update_check_marks()
        
        # Determine next state based on session count
        if self.check_count % 4 == 0:
            self.state = 'long_break'
        else:
            self.state = 'short_break'
    else:
        # Break finished, return to work
        if self.state == 'long_break':
            self.check_count = 0  # Reset after long break
            self.update_check_marks()
        self.state = 'work'
    
    self.start_timer()  # Auto-transition to next state
\end{lstlisting}

\subsection{Dynamic UI Updates and User Feedback}

\subsubsection{Conditional Styling}
\textbf{User Experience:} Update interface based on application state:

\begin{lstlisting}
def start_timer(self):
    """Update UI styling based on current state"""
    if self.state == 'work':
        self.timer_label.config(text="Work Time", fg=self.GREEN)
        self.countdown(self.WORK_MIN * 60)
    elif self.state == 'short_break':
        self.timer_label.config(text="Short Break", fg=self.PINK)
        self.countdown(self.SHORT_BREAK_MIN * 60)
    elif self.state == 'long_break':
        self.timer_label.config(text="Long Break", fg=self.RED)
        self.countdown(self.LONG_BREAK_MIN * 60)
\end{lstlisting}

\subsubsection{Progress Indicators}
\textbf{Visual Feedback:} Provide clear progress indication:

\begin{lstlisting}
def update_check_marks(self):
    """Generate visual progress indicators"""
    # Show completed sessions within current cycle
    marks = 'v' * (self.check_count % 4)
    self.check_label.config(text=marks)
\end{lstlisting}

\section{Professional Code Organization}

\subsection{Separation of Concerns}
\textbf{Architecture:} Organize code into logical, maintainable sections:

\begin{lstlisting}
class PomodoroTimer:
    def __init__(self):
        self.setup_constants()
        self.setup_state()
        self.setup_ui()
    
    def setup_ui(self):
        """Handle all UI creation and configuration"""
        self.create_window()
        self.create_canvas()
        self.create_controls()
        self.create_progress_display()
    
    def create_window(self):
        """Configure main window properties"""
        self.window = Tk()
        self.window.title('Pomodoro Timer')
        self.window.config(padx=100, pady=50, bg=self.YELLOW)
\end{lstlisting}

\subsection{Complete Professional Example}

\begin{tcolorbox}[colback=gray!5!white,colframe=gray!75!black,title=Complete Professional Pomodoro Timer]
\begin{lstlisting}
from tkinter import *
import os

class PomodoroTimer:
    # Constants
    PINK = "#e2979c"
    RED = "#e7305b"
    GREEN = "#9bdeac"
    YELLOW = "#f7f5dd"
    FONT_NAME = "Courier"
    WORK_MIN = 25
    SHORT_BREAK_MIN = 5
    LONG_BREAK_MIN = 20
    
    def __init__(self):
        # Initialize state variables
        self.reset_pressed = False
        self.check_count = 0
        self.state = 'work'
        self.timer_job = None
        self.setup_ui()
    
    def setup_ui(self):
        """Initialize and configure the user interface"""
        self.window = Tk()
        self.window.config(padx=100, pady=50, bg=self.YELLOW)
        self.window.title('Pomodoro Timer')
        
        # Configure grid weights for better layout
        for i in range(3):
            self.window.columnconfigure(i, weight=1)
        
        # Title label
        self.timer_label = Label(
            text='Timer', 
            font=(self.FONT_NAME, 32, 'normal'),
            fg=self.GREEN, 
            bg=self.YELLOW
        )
        self.timer_label.grid(row=0, column=1)
        
        # Canvas with tomato image
        self.canvas = Canvas(
            width=200, height=224, 
            bg=self.YELLOW, 
            highlightthickness=0
        )
        
        # Load image with error handling
        try:
            image_path = os.path.join(os.path.dirname(__file__), 'tomato.png')
            self.tomato_img = PhotoImage(file=image_path)
            self.canvas.create_image(100, 112, image=self.tomato_img)
        except Exception as e:
            print(f"Could not load tomato.png: {e}")
            self.canvas.create_oval(50, 50, 150, 150, 
                                  fill=self.RED, outline=self.GREEN, width=3)
        
        # Timer text on canvas
        self.timer_text = self.canvas.create_text(
            103, 130, 
            text=f'{self.WORK_MIN}:00', 
            fill='white', 
            font=(self.FONT_NAME, 30, "bold")
        )
        self.canvas.grid(row=1, column=1)
        
        # Control buttons
        self.start_button = Button(
            text='Start', 
            command=self.start_timer,
            font=(self.FONT_NAME, 12),
            highlightthickness=0
        )
        self.start_button.grid(row=2, column=0, pady=20)
        
        self.reset_button = Button(
            text='Reset', 
            command=self.reset_timer,
            font=(self.FONT_NAME, 12),
            highlightthickness=0
        )
        self.reset_button.grid(row=2, column=2, pady=20)
        
        # Check marks for completed sessions
        self.check_label = Label(
            text='', 
            fg=self.GREEN, 
            bg=self.YELLOW, 
            font=(self.FONT_NAME, 25, 'normal')
        )
        self.check_label.grid(row=3, column=1)
    
    def start_timer(self):
        """Start the timer with appropriate duration based on current state"""
        if self.state == 'work':
            self.countdown(self.WORK_MIN * 60)
            self.timer_label.config(text="Work", fg=self.GREEN)
        elif self.state == 'short_break':
            self.countdown(self.SHORT_BREAK_MIN * 60)
            self.timer_label.config(text="Short Break", fg=self.PINK)
        elif self.state == 'long_break':
            self.countdown(self.LONG_BREAK_MIN * 60)
            self.timer_label.config(text="Long Break", fg=self.RED)
    
    def countdown(self, count):
        """Handle the countdown mechanism"""
        if self.reset_pressed:
            return
            
        minutes = count // 60
        seconds = count % 60
        time_text = f'{minutes}:{seconds:02d}'
        self.canvas.itemconfig(self.timer_text, text=time_text)
        
        if count > 0:
            self.timer_job = self.window.after(1000, self.countdown, count - 1)
        else:
            self.timer_finished()
    
    def timer_finished(self):
        """Handle timer completion and state transitions"""
        if self.state == 'work':
            self.check_count += 1
            self.update_check_marks()
            
            if self.check_count % 4 == 0:
                self.state = 'long_break'
            else:
                self.state = 'short_break'
        else:
            if self.state == 'long_break':
                self.check_count = 0
                self.update_check_marks()
            self.state = 'work'
        
        self.start_timer()
    
    def update_check_marks(self):
        """Update the checkmark display"""
        marks = 'v' * (self.check_count % 4)
        self.check_label.config(text=marks)
    
    def reset_timer(self):
        """Reset the timer to initial state"""
        self.reset_pressed = True
        
        if self.timer_job:
            self.window.after_cancel(self.timer_job)
        
        # Reset all state variables
        self.state = 'work'
        self.check_count = 0
        self.reset_pressed = False
        
        # Reset UI
        self.timer_label.config(text="Timer", fg=self.GREEN)
        self.canvas.itemconfig(self.timer_text, text=f'{self.WORK_MIN}:00')
        self.check_label.config(text="")
    
    def run(self):
        """Start the application"""
        self.window.mainloop()

# Create and run the application
if __name__ == "__main__":
    app = PomodoroTimer()
    app.run()
\end{lstlisting}
\end{tcolorbox}

\section{Key Learning Progression}

\subsection{From Basic to Professional}

\textbf{Basic Level (Section 27):}
\begin{itemize}
    \item Simple widgets (Label, Button, Entry)
    \item Basic layout with pack() and grid()
    \item Simple event handling
    \item Static interfaces
\end{itemize}

\textbf{Advanced Level (Section 28):}
\begin{itemize}
    \item Canvas graphics and layering
    \item Non-blocking timers and animations
    \item State machines and complex logic
    \item Dynamic UI updates
    \item Error handling and robustness
    \item Professional code organization
\end{itemize}

\subsection{Design Patterns Learned}

\begin{enumerate}
    \item \textbf{Model-View Pattern:} Separate data (state) from presentation (UI)
    \item \textbf{State Machine Pattern:} Manage complex state transitions
    \item \textbf{Observer Pattern:} Update UI based on state changes
    \item \textbf{Command Pattern:} Encapsulate actions in button callbacks
\end{enumerate}

\section{Best Practices Summary}

\subsection{Code Organization}
\begin{itemize}
    \item Use classes for complex applications
    \item Separate UI creation from business logic
    \item Group related functionality together
    \item Use descriptive method and variable names
\end{itemize}

\subsection{State Management}
\begin{itemize}
    \item Centralize state in class attributes
    \item Implement clear state transition logic
    \item Use enums or constants for state values
    \item Update UI consistently when state changes
\end{itemize}

\subsection{Error Handling}
\begin{itemize}
    \item Always validate user inputs
    \item Provide fallbacks for missing resources
    \item Use try-except blocks around risky operations
    \item Give users meaningful error feedback
\end{itemize}

\subsection{Performance}
\begin{itemize}
    \item Use \texttt{after()} for non-blocking operations
    \item Cancel timer jobs when resetting
    \item Avoid blocking the main thread
    \item Update UI efficiently (batch changes when possible)
\end{itemize}

\section{Common Pitfalls and Solutions}

\begin{enumerate}
    \item \textbf{Forgetting mainloop()}: Always call \texttt{window.mainloop()} at the end
    \item \textbf{Mixing layout managers}: Don't use pack() and grid() in the same container
    \item \textbf{Timer job leaks}: Always cancel timer jobs when resetting
    \item \textbf{Blocking operations}: Use \texttt{after()} instead of \texttt{time.sleep()}
    \item \textbf{Missing error handling}: Provide fallbacks for file operations
\end{enumerate}

\section{Additional Resources}

\begin{itemize}
    \item \textbf{Official Tkinter Documentation:} \url{https://docs.python.org/3/library/tkinter.html}
    \item \textbf{Tkinter Tutorial:} \url{https://tkdocs.com/tutorial/}
    \item \textbf{Canvas Widget Reference:} \url{https://www.tcl-lang.org/man/tcl8.6/TkCmd/canvas.htm}
    \item \textbf{Grid Geometry Manager:} \url{https://www.tcl-lang.org/man/tcl8.6/TkCmd/grid.htm}
\end{itemize}

\section{Conclusion}

Sections 27 and 28 together provide a comprehensive foundation for professional GUI development in Python:

\textbf{Core Foundations (Section 27):}
\begin{itemize}
    \item \textbf{*args and **kwargs} enable flexible function interfaces
    \item \textbf{Basic Tkinter widgets} provide building blocks for applications
    \item \textbf{Layout managers} control widget positioning
    \item \textbf{Event handling} creates interactive experiences
\end{itemize}

\textbf{Advanced Techniques (Section 28):}
\begin{itemize}
    \item \textbf{Canvas graphics} enable sophisticated visual interfaces
    \item \textbf{Non-blocking timers} maintain responsive applications
    \item \textbf{State management} handles complex application logic
    \item \textbf{Professional practices} ensure robust, maintainable code
\end{itemize}

\textbf{Key Achievements:}
\begin{enumerate}
    \item Progression from basic widgets to complex applications
    \item Understanding of professional coding practices
    \item Ability to create responsive, error-resistant GUIs
    \item Knowledge of design patterns and architectural principles
\end{enumerate}

This learning journey demonstrates how Python's Tkinter library can be used to create professional desktop applications. The combination of fundamental concepts with advanced techniques provides a solid foundation for GUI development and prepares students for more complex frameworks like PyQt, wxPython, or modern web-based interfaces.

The skills learned here transfer directly to other GUI frameworks and provide essential knowledge for any developer working on user-facing applications.

\end{document}
